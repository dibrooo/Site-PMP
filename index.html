<html>
	<head>
		<title>PMP</title>
		<link rel="stylesheet" href="estilos.css"/>
		<link rel="preconnect" href="https://fonts.gstatic.com">
		<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata">
		<link href="https://fonts.googleapis.com/css2?family=Josefin+Sans&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Mada&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Didact+Gothic&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Raleway:wght@100&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Raleway&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Dosis&family=Staatliches&display=swap" rel="stylesheet">
	</head>
	
	<body>
		<div id="barra"></div>
		<div id="scroll"></div>

		<div class="gradient-border" id="box">
			<h1>Princípios Metodológicos da Programação</h1>
		</div>
		
		<div id="geral">
			<div id="topo">
				<ul class="menu">
					<a href="sobre.html">
						<span></span>
						<span></span>
						<span></span>
						<span></span>
						Sobre
					</a>
					<a href="index.html" class="ativo">
						<span></span>
						<span></span>
						<span></span>
						<span></span>
						Trabalhos
					</a>
					<a href="ufcd.html">
						<span></span>
						<span></span>
						<span></span>
						<span></span>
						A UFCD
					</a>
				</ul>
			</div>
			<div>
				<!--5º Trabalho-->
				<details>
					<summary class="neon">Dicionário de dados</summary>

					<div class="slides">
						<div class="t1s1">
							<h2>Dicionário</h2>
							<h2 class="cinza">de dados</h2>
						</div>
						<div class="t1s2">
							<img src="./imagens/trabalho5/image1.jpg">
							<div class="t1s2i1">
								<dt>01</dt>
								<dd>Introdução</dd>
							</div>
							<div class="t1s2i2">
								<dt>02</dt>
								<dd>Definição de dicionário de dados</dd>
							</div>
							<div class="t1s2i3">
								<dt>03</dt>
								<dd>Dicionário de dados em programação</dd>
							</div>
							<div class="t1s2i4">
								<dt>04</dt>
								<dd>Conclusão</dd>
							</div>
						</div>
						<div class="t1s3">
							<p>Neste trabalho vamos falar sobre <mark>o que é</mark> um dicionário de dados em <mark>geral</mark> e em <mark>programação</mark>.</p>
						</div>
						<div class="t1s4">
							<div>
								<h3>Definição de </h3> <h3 class="cinza"> dicionário de dados</h3>
							</div>
							<p>Um dicionário de dados é uma <mark>coleção de metadados</mark> que contém definições e representações de elementos de dados.</p>
							<img src="./imagens/trabalho5/image4.png">
						</div>
						<div class="t1s5">
							<div>
								<h3>Dicionário de </h3> <h3 class="cinza"> dados em programação</h3>
							</div>
							<p>Um dicionário de dados é uma <mark>coleção de descrições dos objetos ou itens</mark> de dados num modelo de dados para benefício dos programadores e outros que precisam de se referir a eles. Muitas vezes um dicionário de dados é um repositório centralizado de metadados.</p>
							<img src="./imagens/trabalho5/image5.jpg">
						</div>
						<div class="t1s6">
							<div>
								<h3>Conclu</h3><h3 class="cinza">são</h3>
							</div>
							<p>No modo <mark>geral</mark> dicionário de dados é uma <mark>coleção de metadados</mark> que contém definições e representações de elementos de dados, na <mark>programação</mark>, é uma <mark>coleção de descrições</mark> dos objetos ou itens de dados num modelo de dados.</p>
							<img src="./imagens/trabalho5/image3.jpg">
						</div>
					</div>
				</details>
				
				<!--4º Trabalho-->
				<details>
					<summary class="neon">Corpo de um programa</summary>
					
					<div class="slides">
						<div class="t2s1">
							<h2>Corpo de um programa</h2>
						</div>
						<div class="t2s2">
							<h3>Índice</h3>
							<div class="t2s2i1">
								<dt>01</dt>
								<dd>Introdução</dd>
								<dt>03</dt>
								<dd>Tratamento de estrutura de dados</dd>
							</div>
							<div class="t2s2i2">
								<dt>02</dt>
								<dd>Desenvolvimento da sequência</dd>
								<dt>04</dt>
								<dd>Regras de gestão</dd>
							</div>
							<div class="t2s2i3">
								<dt>05</dt>
								<dd>Conclusão</dd>
							</div>
						</div>
						<div class="t2s3">
							<h3>Introdução</h3>
							<p>Neste trabalho vamos falar sobre o desenvolvimento da sequência, o tratamento de estrutura de dados e sobre as regras de gestão.</p>
							<img src="./imagens/trabalho4/image1.jpg">
						</div>
						<div class="t2s4">
							<img src="./imagens/trabalho4/image2.jpg">
							<h3>Desenvolvimento da sequência</h3>
							<p>Um processo de desenvolvimento de software é um conjunto de atividades, parcialmente ordenadas, com a finalidade de obter um produto de software. É estudado dentro da área de Engenharia de Software, sendo considerado um dos principais mecanismos para se obter software de qualidade e cumprir corretamente os contratos de desenvolvimento, sendo uma das respostas técnicas adequadas para resolver a crise do software.</p>
						</div>
						<div class="t2s5">
							<img src="./imagens/trabalho4/image3.png">
							<h3>Tratamento de estrutura de dados</h3>
							<p>O tratamento abrange um amplo conjunto de operações efetuadas sobre dados pessoais, por meios manuais ou automatizados. Inclui a recolha, o registo, a organização, a estruturação, a conservação, a adaptação ou alteração, a recuperação, a consulta, a utilização, a divulgação por transmissão, difusão ou qualquer outra forma de disponibilização, a comparação ou interconexão, a limitação, o apagamento ou a destruição de dados pessoais.</p>
						</div>
						<div class="t2s6">
							<h3>Regras de gestão</h3>
							<div class="t2s6cfix">
								<h4>Trabalho</h4>
								<p>Um trabalho é uma posição dentro de uma organização e geralmente é definido na descrição do trabalho, que descreve o que se espera da pessoa que irá desempenhar tal trabalho e suas habilidades e atributos.</p>
							</div>
							<div class="t2s6c">
								<h4>Função</h4>
								<p>Dentro de cada trabalho, há pelo menos uma função a ser assumida. No gerenciamento de projetos e programas, geralmente há várias funções associadas a cada trabalho, dependendo das necessidades e da fase do ciclo de vida do programa.</p>
							</div>
							<div class="t2s6c">
								<h4>Responsabilidades</h4>
								<p>Para cada função assumida, existe um conjunto de responsabilidades associadas. No entanto, nem todas as responsabilidades associadas precisam ser satisfeitas em todas as ocasiões. As responsabilidades exigidas variam dependendo do tipo de iniciativa e do momento dentro do ciclo de vida do programa.</p>
							</div>
						</div>
						<div class="t2s7">
							<h3>Conclusão</h3>
							<p>Um processo de desenvolvimento de software é um conjunto de atividades, parcialmente ordenadas, com a finalidade de obter um produto de software. O tratamento abrange um amplo conjunto de operações efetuadas sobre dados pessoais, por meios manuais ou automatizados. As regras de gestão dividem-se em trabalho, função e responsabilidades.</p>
							<img src="./imagens/trabalho4/image4.png">
						</div>
					</div>
				</details>

				<!--3º Trabalho-->
				<details>
					<summary class="neon">Estrutura de um programa</summary>
					<div class="slides">
						<div class="t3s1">
							<h2>Estrutura de um programa</h2>
						</div>
						<div class="t3s2">
							<h3>Índice</h3>
							<div class="t3s2i1">
								<dt>01</dt>
								<dd>Introdução</dd>
								<dt>03</dt>
								<dd>Sequencia das instruções nos procedimentos</dd>
							</div>
							<div class="t3s2i2">
								<dt>02</dt>
								<dd>Regras de dedução para a identificação dos procedimentos</dd>
								<dt>04</dt>
								<dd>Condições do seu emprego no controlo das estruturas lógicas</dd>
							</div>
							<div class="t3s2i3">
								<dt>05</dt>
								<dd>Conclusão</dd>
							</div>
						</div>
						<div class="t3s3">
							<h3>Introdução</h3>
							<p>Neste trabalho vamos falar sobre as regras para a identificação dos procedimentos, a sequência das instruções nos procedimentos e as suas condições no controlo das estruturas lógicas.</p>
							<img src="./imagens/trabalho3/imagem1.png">
						</div>
						<div class="t3s4">
							<h3>Regras de dedução para a identificação dos procedimentos</h3>
							<p>
								As regras estendem as capacidades de um programa lógico. São eles que dão à Prolog a capacidade de seguir seu processo de tomada de decisão.</br>
								Por exemplo:</br>
								A primeira regra é lida como segue: `` Faz calor se é verão e está ensolarado. '' A segunda regra é lida da seguinte forma: `` Faz frio se é inverno e está nevando. ''
							</p>
							<div class="t3s4e">
								<div class="t3s4c">
									<img src="./fundos/trabalho3/slide4gr.png">
									<h4>Está quente</h4>
									<p>É verão</p>
									<h6>Está ensolarado</h6>
								</div>
								<div class="t3s4c">
									<img src="./fundos/trabalho3/slide4gr.png">
									<h4>Está frio</h4>
									<p>É inverno</p>
									<h6>Está nevando</h6>
								</div>
							</div>
						</div>
						<div class="t3s5">
							<img src="./imagens/trabalho3/imagem2.png">
							<h3>Sequencia das instruções nos procedimentos</h3>
							<p>São as operações que um processador, microprocessador, microcontrolador, CPU ou outros periféricos programáveis suporta, fornece ou disponibiliza para o programador, ou seja, é a representação em mnemônicos do código de máquina, com a finalidade de facilitar o acesso ao componente.</p>
						</div>
						<div class="t3s6">
							<h3>Condições do seu emprego no controlo das estruturas lógicas</h3>
							<div class="t3s6c1">
								<img src="./fundos/trabalho3/slide6gr.png" alt="">
								<h6>condição</h6>
								<h4>if</h4>
								<p>
									if ( A ) {<br/>
										Código se A for verdadeiro;<br/>
									}<br/>				
								</p>
							</div>
							<div class="t3s6c2">
								<img src="./fundos/trabalho3/slide6gr.png" alt="">
								<h6>condição</h6>
								<h4>if...else</h4>
								<p>
									if ( A ) {<br/>
										Código se A verdadeiro;<br/>
									} else {<br/>
										Código se A falso;<br/>
									}<br/>							
								</p>
							</div>
							<div class="t3s6c3">
								<img src="./fundos/trabalho3/slide6gr.png" alt="">
								<h6>condição</h6>
								<h4>if...elseif<br/>...else</h4>
								<p>
									if ( A ) {<br/>
										Código se A;<br/>
									}<br/>
									elseif ( B ) {<br/>
										Código se B;<br/>
									}<br/>
									else {<br/>
										Código se nem A, nem B;<br/>
									}<br/>
								</p>
							</div>
						</div>
						<div class="t3s7">
							<h3>Conclusão</h3>
							<p>Em suma, as regras estendem as capacidades de um programa lógico, as sequências são operações que um processador suporta e as suas condições são: IF, IF…ELSE, IF…ELSEIF…ELSE.</p>
							<img src="./imagens/trabalho3/imagem3.png" alt="">
						</div>
					</div>
				</details>

				<!--2º Trabalho-->
				<details>
					<summary class="neon">Princípios do método</summary>
					<div class="slides">
						<div class="t4s1">
							<h2>Princípios do método</h2>
						</div>
						<div class="t4s2">
							<h3>Índice</h3>
							<div class="t4s2i1">
								<dt>01</dt>
								<dd>Introdução</dd>
							</div>
							<div class="t4s2i2">
								<dt>02</dt>
								<dd>Teoria dos conjuntos aplicada aos dados</dd>
							</div>
							<div class="t4s2i3">
								<dt>03</dt>
								<dd>Representação gráfica dos conjuntos</dd>
							</div>
							<div class="t4s2i4">
								<dt>04</dt>
								<dd>Conjunto teórico-núcleo</dd>
							</div>
							<div class="t4s2i5">
								<dt>05</dt>
								<dd>Conjuntos estáticos</dd>
							</div>
							<div class="t4s2i6">
								<dt>06</dt>
								<dd>Conjuntos dinâmicos</dd>
							</div>
							<div class="t4s2i7">
								<dt>07</dt>
								<dd>Operações adicionais</dd>
							</div>
							<div class="t4s2i8">
								<dt>08</dt>
								<dd>Dados agrupados em conjuntos</dd>
							</div>
							<div class="t4s2i9">
								<dt>09</dt>
								<dd>Entrada e saída de dados</dd>
							</div>
							<div class="t4s2i10">
								<dt>10</dt>
								<dd>Conclusão</dd>
							</div>
						</div>
						<div class="t4s3">
							<h3>Introdução</h3>
							<p>Neste trabalho vamos falar sobre a teoria dos conjuntos aplicada aos dados, vamos também mostrar a representação gráfica dos conjuntos e as operações dos conjuntos. Em relação aos dados iremos falar sobre os dados agrupados em conjunto e sobre a entrada e saída de dados.</p>
						</div>
						<div class="t4s4">
							<h3>Teoria dos conjuntos aplicada aos dados</h3>
							<p>Na teoria dos tipos, os conjuntos são geralmente identificados com sua função de indicador (função característica): consequentemente, um conjunto de valores de tipo A pode ser denotado por 2A ou P(A). (Subtipos e subconjuntos podem ser modelados por tipos de refinamento , e conjuntos de quocientes podem ser substituídos por setoides.) A função característica F de um conjunto S é definido como:</p>
							<img class="t4s4f" src="./imagens/trabalho2/imagem1.png" alt="">
							<span>Em teoria, muitas outras estruturas de dados abstratas podem ser vistas como estruturas de conjunto com operações adicionais e / ou axiomas adicionais impostos às operações padrão. Por exemplo, um heap abstrato pode ser visto como uma estrutura definida com uma operação que retorna o elemento de menor valor. min(S)</span>
							<img class="t4s4i" src="./imagens/trabalho2/imagem2.png" alt="">
						</div>
						<div class="t4s5">
							<h3>Representação gráfica dos conjuntos</h3>
							<img class="t4s5r1" src="./imagens/trabalho2/imagem3.png" alt="">
							<img class="t4s5r2" src="./imagens/trabalho2/imagem4.png" alt="">
							<p> Matriz de adjacência</p>
							<span>Lista de adjacência</span>
						</div>
						<!--slide 6-->
						<div class="t4s6_10">
							<h3>Conjunto teórico-núcleo</h3>
							<p>Pode-se definir as operações da álgebra de conjuntos com:</p>
							<ul class="t4s6_10c1">
								<li>union(S,T): Retorna a união de conjuntos S e T.</li>
								<li>intersection(S,T): Retorna a intersecção de conjuntos S e T.</li>
							</ul>
							<ul class="t4s6_10c2">
								<li>difference(S,T): Retorna a diferença de conjuntos S e T.</li>
								<li>subset(S,T): Um predicado que testa se o conjunto S é um subconjunto do conjunto T.</li>
							</ul>
						</div>
						<!--slide 7-->
						<div class="t4s6_10">
							<h3>Conjunto estático</h3>
							<p>As operações típicas que podem ser fornecidas por uma estrutura de conjunto estático S são:</p>
							<ul class="t4s6_10c1">
								<li>is_element_of(x,S): Verifica se o valor x está no conjunto S.</li>
								<li>is_empty(S): verifica se o conjunto S está vazio.</li>
								<li>size(S)ou : devolve o número de elementos em S .cardinality(S).</li>
								<li>iterate(S): retorna uma função que retorna mais um valor de S em cada chamada, em alguma ordem arbitrária.</li>
							</ul>
							<ul class="t4s6_10c2">
								<li>enumerate(S): retorna uma lista contendo os elementos de S em alguma ordem arbitrária.</li>
								<li>build(x1,x2,…,xn,): cria uma estrutura de conjunto com valores x 1 , x 2 , ..., x n.</li>
								<li>create_from(collection): cria uma nova estrutura de conjunto contendo todos os elementos da coleção fornecida ou todos os elementos retornados pelo iterador fornecido.</li>
							</ul>
						</div>
						<!--slide 8-->
						<div class="t4s6_10">
							<h3>Conjunto dinâmico</h3>
							<p>Estruturas de conjuntos dinâmicos normalmente adicionam:</p>
							<ul class="t4s6_10c1">
								<li>create(): cria uma nova estrutura de conjunto inicialmente vazia.</li>
								<li>create_with_capacity(n): cria uma nova estrutura de conjunto, inicialmente vazia, mas capaz de conter até n elementos.</li>
							</ul>
							<ul class="t4s6_10c2">
								<li>add(S,x): adiciona o elemento x a S , se ainda não estiver presente.</li>
								<li>remove(S, x): remove o elemento x de S , se estiver presente.</li>
								<li>capacity(S): retorna o número máximo de valores que S pode conter.</li>
							</ul>
						</div>
						<!--slide 9-->
						<div class="t4s6_10">
							<h3>Conjunto adicional</h3>
							<p>Existem muitas outras operações que podem (em princípio) ser definidas nos termos acima, tais como:</p>
							<ul class="t4s6_10c1">
								<li>pop(S): Retorna um elemento arbitrário de S, eliminando-o a partir de S.</li>
								<li>pick(S): Retorna um elemento arbitrário de S. Funcionalmente, o mutador poppode ser interpretado como o par de seletores (pick, rest),onde restretorna o conjunto constituído por todos os elementos exceto o elemento arbitrário. Pode ser interpretado em termos de iterate.</li>
								<li>map(F,S): Devolve o conjunto de valores distintos resultantes de aplicar a função F a cada elemento de S.</li>
								<li>filter(P,S): Retorna o subconjunto que contém todos os elementos de S que satisfazem um dado predicado P .</li>
							</ul>
							<ul class="t4s6_10c2">
								<li>fold(A0,F,S): retorna o valor A | S | depois de aplicar para cada elemento e de S, para alguma operação binária F. F deve ser associativo e comutativo para que seja bem definido. Ai+1 := F(Ai, e).</li>
								<li>clear(S): Eliminar todos os elementos de S.</li>
								<li>equal(S1', S2'): verifica se os dois conjuntos fornecidos são iguais (ou seja, contêm todos e apenas os mesmos elementos).</li>
								<li>hash(S): retorna um valor hash para o conjunto estático S de modo que se então equal(S1, S2)hash(S1) = hash(S2).</li>
							</ul>
						</div>
						<!--slide 10-->
						<div class="t4s6_10">
							<h3>Conjunto adicional</h3>
							<p>Outras operações podem ser definidas para conjuntos com elementos de um tipo especial:</p>
							<ul class="t4s6_10c1">
								<li>sum(S): retorna a soma de todos os elementos de S para alguma definição de "soma". Por exemplo, em números inteiros ou reais, pode ser definido como .fold(0, add, S).</li>
								<li>collapse(S): dado um conjunto de conjuntos, retorna a união. Por exemplo collapse({{1}, {2, 3}}) == {1, 2, 3},. Pode ser considerado uma espécie de sum.</li>
								<li>nearest(S,x): retorna o elemento de S que é o mais próximo em valor de x (por alguma métrica ).</li>
							</ul>
							<ul class="t4s6_10c2">
								<li>flatten(S): dado um conjunto que consiste em conjuntos e elementos atómicos (elementos que não são conjuntos), retorna um conjunto cujos elementos são os elementos atómicos do conjunto de nível superior original ou elementos dos conjuntos que ele contém. Em outras palavras, remova um nível de aninhamento - como, collapse,mas permite átomos. Isso pode ser feito uma única vez ou nivelando recursivamente para obter um conjunto de apenas elementos atómicos. Por exemplo flatten({1, {2, 3}}) == {1, 2, 3}.</li>
								<li>min(S): Retorna o elemento mínimo / máximo de S .max(S).</li>
							</ul>
						</div>
						<div class="t4s11">
							<h3>Dados agrupados em conjuntos</h3>
							<p>Dados agrupados são dados formados pela agregação de observações individuais de uma variável em grupos, de modo a que uma distribuição de frequência destes grupos sirva como um meio conveniente para resumir ou analisar os dados.<br/>
								Existem dois tipos principais de agrupamento: agrupamento de dados de uma variável unidimensional, substituindo números individuais por contagens em caixas; e agrupamento de variáveis multidimensionais por algumas das dimensões (especialmente por variáveis independentes), obtendo a distribuição de dimensões não agrupadas (especialmente as variáveis dependentes).</p>
						</div>
						<div class="t4s12">
							<h3>Entrada e saída de dados</h3>p
							<p>Entradas e saídas são a comunicação do programa com o mundo real, a forma com que o programa recebe os dados a serem processados do mundo real e devolve a este a resposta.<br/>
								A entrada pode ser feita pelo teclado, mouse, arquivos de texto - através do redirecionamento da entrada padrão e de outros dispositivos físicos de Entrada.<br/>
								A saída pode ser feita no vídeo, na impressora, arquivos texto - através do redirecionamento da saída padrão, e de outros dispositivos de Saída.</p>
								<img src="./imagens/trabalho2/imagem5.jpg" alt="">
						</div>
						<div class="t4s13">
							<h3>Conclusão</h3>
							<p>Na teoria dos tipos, os conjuntos são geralmente identificados com sua função de indicador.  As operações sobre conjuntos são: operações de conjunto teórico-núcleo, conjuntos estáticos, conjuntos dinâmicos e operações adicionais.<br/>
								Dados agrupados são dados formados pela agregação de observações individuais de uma variável em grupos. Entradas e saídas de dados são a comunicação do programa com o mundo real.</p>
						</div>
					</div>
				</details>

				<!--1º Trabalho-->
				<details>
					<summary class="neon">Metodologia em programação local</summary>
					
					<div class="trabalho5">
						<div class="t5s1">
							<h2>Princípios Metodológicos de Programação</h2>
						</div>
						<div class="t5s2">
							<h3>Índice</h3>
							<ul class="t5s2c1">
								<li>Introdução</li>
								<li>Evolução</li>
								<li>Metodologia Ágil</li>
								<li>Scrum</li>
								<li>Kanban</li>
								<li>Cascata</li>
								<li>Lean</li>
							</ul>
							<ul class="t5s2c2">
								<li>Programação orientada por objeto</li>
								<li>Os seus 4 pilares: Abstração</li>
								<li>Os seus 4 pilares: Encapsulamento</li>
								<li>Os seus 4 pilares: Herança</li>
								<li>Os seus 4 pilares: Polimorfismo</li>
								<li>Conclusão</li>
							</ul>
						</div>
						<div class="t5s3">
							<h3>Introdução</h3>
							<p>Neste trabalho vamos falar sobre a evolução das metodologias de programação, quais são os tipos e as suas vantagens e desvantagens. O que é programação orientada por objeto e os seus 4 pilares.</p>
						</div>
						<div class="t5s4">
							<h3>Evolução</h3>
							<img src="./imagens/trabalho1/imagem1.png" alt="">
							<div class="t5s4t1">
								<p>Em meados da primeira guerra mundial tivemos uma evolução significativa no segmento corporativo.</p>
							</div>
							<div class="t5s4t2">
								<p>Nesta época o mundo passava por intensas transformações e isto provocou drásticas mudanças no ciclo produtivo das empresas e percebeu-se a necessidade de controlar o seu processo de trabalho.</p>
							</div>
							<div class="t5s4t3">
								<p>Com a criação dos computadores comerciais após a segunda guerra mundial tivemos um aumento significativo na  dinamização da indústria de computadores e, consequentemente, o processo de construção de softwares, para que os mesmos automatizassem processos manuais e pudessem avaliar situações complexas que são parte integrante do cotidiano das organizações.</p>
							</div>
							<div class="t5s4t4">
								<p>E a partir desse cenário, criou-se modelos de desenvolvimento de softwares que atendessem a determinadas necessidades específicas e ao mesmo tempo pudessem ser utilizados na elaboração softwares sem grandes complexidades.</p>
							</div>
						</div>
						<div class="t5s5_9">
							<h3>Metodologia Ágil</h3>
							<p>
								Trata-se de uma metodologia de desenvolvimento de software com foco no próprio projeto ou produto.<br/>
								Ela visa a realização de melhorias e alterações constantes, baseadas no feedback dos usuários, dos próprios clientes e até do time interno de criação. <br/>
								Sem estruturas rígidas, o processo visa períodos curtos de desenvolvimento, para que os resultados e seus respetivos feedbacks sejam obtidos de maneira rápida.
							</p>
							<img src="./imagens/trabalho1/imagem2.png" alt="">
						</div>
						<div class="t5s10_14">
							<div class="t5s10_14v">
								<dt>Vantagens</dt>
									<dd>As metodologias ágeis podem ser focadas no desenvolvimento do software em si. A cada etapa do projeto, o cliente recebe um software real com as funcionalidades implementadas, sendo assim, é possível entregar um produto de qualidade em menos tempo;</dd>
									<dd>Como é muito improvável que o cliente não vá mudar nada na especificação inicial do software, a cada versão recebida, o cliente tem a chance de enviar uma sugestão de mudanças e a equipe de desenvolvimento já começa a implementar essas alterações para a próxima versão do software;</dd>
									<dd>Durante todo o processo de desenvolvimento de software, nas metodologias ágeis, são executados testes e validações de funcionalidades com o próprio cliente;</dd>
									<dd>Uma das premissas das metodologias ágeis é estimular o contato entre os envolvidos no projeto, por isso, a comunicação entre o cliente e os desenvolvedores deverá ser bem próxima;</dd>
									<dd>Com a constante comunicação entre a equipe de desenvolvimento e o cliente, além de receber as versões do software, o cliente é capaz de identificar possíveis problemas e reportá-los diretamente aos desenvolvedores para que os mesmos sejam solucionados o mais rápido possível.</dd>
							</div>
							<div class="t5s10_14dv">
								<dt>Desvantagens</dt>
									<dd>Para trabalhar com as metodologias ágeis não é essencial que a sua equipe seja especialista acerca dos métodos, mas é preciso que todos os membros sejam dedicados, interessados em aprender e otimizar sua performance – tanto individualmente quanto coletivamente;</dd>
									<dd>Além disso, é fundamental que os integrantes do seu time estejam dispostos a se adaptarem conforme as necessidades de cada demanda.</dd>
							</div>
						</div>
						<div class="t5s5_9">
							<h3>Scrum</h3>
							<p>
								O método Scrum funciona como uma etapa adicional da Metodologia Ágil. Seu objetivo é ter mais produtividade nos processos.<br/>
								Seus recursos incluem a criação de listas sobre os trabalhos pendentes, reuniões diárias para discutir a direção e o progresso do projeto, sessões de planejamento para pendências futuras e reflexões sobre os meios de resolução de pendências anteriores.
							</p>
							<img src="./imagens/trabalho1/imagem3.png" alt="">
						</div>
						<div class="t5s10_14">
							<div class="t5s10_14v">
								<dt>Vantagens</dt>
									<dd>Existe uma grande motivação nas equipas, devido ao facto de os programadores quererem cumprir o prazo de entrega de cada sprint
									</dd>
									<dd>A transparência existente permite que o projeto possa ser acompanhado por todos os membros de uma equipa ou mesmo de uma organização;
									</dd>
									<dd>O foco na qualidade é uma constante no método Scrum, o que faz com que existam muito menos erros
									</dd>
									<dd>A dinâmica que caracteriza este método permite aos developers a reorganização de prioridades, garantindo que as sprints que ainda não foram terminadas possam receber mais atenção
									</dd>
							</div>
							<div class="t5s10_14dv">
								<dt>Desvantagens</dt>
									<dd>A segmentação do projeto e a procura pela agilidade de desenvolvimento pode, por vezes, levar a equipa a perder a noção do projeto como um todo, concentrando-se apenas na sua parte;
									</dd>
									<dd>A função de cada developer pode não estar bem definida, o que pode fazer com que alguns membros da equipa fiquem confusos
									</dd>
							</div>
						</div>
						<div class="t5s5_9">
							<h3>Kanban</h3>
							<p>
								O desenvolvimento Kanban é excelente para equipes que recebem muitos pedidos, que por sua vez variam muito em termos de tamanho e prioridades.<br/>
								Isso porque o método permite uma melhor visualização do trabalho e limitação das atividades em andamento, mudando com agilidade os processos ainda em realização para concluídos. Nele, as atualizações já são liberadas assim que estiverem prontas, sem a necessidade de uma programação regular com datas de vencimento bem delimitadas. Assim, não existe um período fixo para a entrega das tarefas.
							</p>
							<img src="./imagens/trabalho1/imagem4.png" alt="">
						</div>
						<div class="t5s10_14">
							<div class="t5s10_14v">
								<dt>Vantagens</dt>
									<dd>Capacidade de visualização sobre todas as tarefas de um projeto;
									</dd>
									<dd>Possibilidade de limitar o número de tarefas em andamento;
									</dd>
									<dd>Concentração na duração de um ciclo – quanto tempo demora uma tarefa para ir do backlog até à fase final;
									</dd>
									<dd>Permite entregas contínuas.
									</dd>
							</div>
							<div class="t5s10_14dv">
								<dt>Desvantagens</dt>
									<dd>Existe a possibilidade de os membros de uma equipa poderem interpretar mal a informação refletida no Kanban Board, especialmente quando este se revela ultrapassado;
									</dd>
									<dd>Como não existem timeframes no Kanban, existe a hipótese de se enfrentar problemas de falta de tempo ou de atrasos, associados a cada uma das fases.
									</dd>
							</div>
						</div>
						<div class="t5s5_9">
							<h3>Cascata</h3>
							<p>
								Considerada oposta à Metodologia Ágil, a abordagem em Cascata visa a adoção de controles e processos lineares muito rigorosos.<br/>
								Nela, uma nova etapa só pode ser começada quando as anteriores forem concluídas, para que as ações sejam orientadas gradualmente até as próximas responsabilidades previstas.
							</p>
							<img src="./imagens/trabalho1/imagem5.png" alt="">
						</div>
						<div class="t5s10_14">
							<div class="t5s10_14v">
								<dt>Vantagens</dt>
									<dd>Por causa de sua natureza separada em unidades, o modelo em cascata possibilita a implementação concorrente entre vários programadores, agilizando a entrega;
									</dd>
									<dd>É útil quando o pessoal envolvido no projeto é fraco tecnicamente;
									</dd>
									<dd>O modelo apresenta uma grande vantagem quando o escopo do trabalho é claramente definido. Se as especificações estiverem corretas, um software pode ser desenvolvido de forma muito rápida.
									</dd>
							</div>
							<div class="t5s10_14dv">
								<dt>Desvantagens</dt>
									<dd>É muito difícil retornar para as fases anteriores para corrigir problemas detetados posteriormente;
									</dd>
									<dd>Muito tempo é gasto para garantir que as fases sejam executadas corretamente;
									</dd>
									<dd>Demora muito para o cliente ver algum resultado;
									</dd>
									<dd>Esconde os riscos por muito tempo, retardando sua resolução;
									</dd>
							</div>
						</div>
						<div class="t5s5_9">
							<h3>Lean</h3>
							<p>
								O conceito Lean diz respeito ao desenvolvimento enxuto de um projeto, que se concentra principalmente na diminuição de suas perdas.<br/>
								Nele, o valor a ser gerado para os clientes é o principal ponto de todas as atividades. Ou seja, se determinada ação vale a pena, ela deve ser realizada imediatamente. Se não for o caso, ela deve ser removida.
								Com isso, todo o projeto é examinado minuciosamente já em sua fase inicial, visando a remoção de etapas que podem comprometer o tempo ou os recursos para a sua realização. O feedback também tem suma importância nessa fase.
							</p>
							<img src="./imagens/trabalho1/imagem6.png" alt="">
						</div>
						<div class="t5s10_14">
							<div class="t5s10_14v">
								<dt>Vantagens</dt>
									<dd>Permite à equipa a eliminação de atividade supérflua, poupando tempo e dinheiro;
									</dd>
									<dd>Diminui o tempo necessário para entregar funcionalidades, já que capacita a equipa de desenvolvimento no processo de tomada de decisão, aumentando a motivação geral;
									</dd>
									<dd>Metodologia facilmente escalável e de fácil adaptação a projetos de qualquer dimensão.
									</dd>
							</div>
							<div class="t5s10_14dv">
								<dt>Desvantagens</dt>
									<dd>Metodologia muito dependente da capacidade de desenvolvimento da equipa e do cumprimento dos princípios Lean, o que significa que será necessário ter developers extremamente dedicados e talentosos;
									</dd>
									<dd>Pode existir maior propensão para perder o foco, já que existem várias tarefas divididas por vários elementos;
									</dd>
									<dd>Requer alguma documentação, nomeadamente sobre as características de negócio para o qual se trabalha. Caso contrário, corre-se o risco de o desenvolvimento ser feito de forma incorreta ou apresentar falhas.
									</dd>
							</div>
						</div>
						<div class="t5s15">
							<h3>PROGRAMAÇÃO ORIENTADA POR OBJETOS</h3>
							<p>Programação orientada por objetos é um paradigma de programação baseado no conceito de "objetos", que podem conter dados na forma de campos, também conhecidos como atributos, e códigos, na forma de procedimentos, também conhecidos como métodos.</p>
							<img src="./imagens/trabalho1/imagem7.png" alt="">
						</div>
						<div class="t5s16_19">
							<h3>Os seus 4 pilares</h3>
							<h4>1- Abstração</h4>
							<p>
								São três pontos que devem ser levados em consideração nessa abstração.<br/>
								1- <mark>Identidade ao objeto que iremos criar.</mark> Essa identidade deve ser única dentro do sistema para que não haja conflito. Na maior parte das linguagens, há o conceito de pacotes (ou namespaces).<br/>
								2- <mark>As características do objeto.</mark> Como sabemos, no mundo real qualquer objeto possui elementos que o definem. Dentro da programação orientada a objetos, essas características são nomeadas propriedades. Por exemplo, as propriedades de um objeto “Cão” poderiam ser “Tamanho”, “Raça” e “Idade”.<br/>
								3- <mark>Definir as ações que o objeto irá executar.</mark> Essas ações, ou eventos, são chamados métodos. Esses métodos podem ser extremamente variáveis, desde “Acender()” em um objeto lâmpada até “Miar()” em um objeto gato.
							</p>
							<img src="./imagens/trabalho1/imagem8.png" alt="">
						</div>
						<div class="t5s16_19">
							<h3>Os seus 4 pilares</h3>
							<h4>2- Encapsulamento</h4>
							<p>
								Trata-se de um dos elementos que adiciona segurança à aplicação em uma programação orientada a objetos pelo fato de esconder as propriedades.<br/>
								A maior parte das linguagens orientadas a objetos implementam o encapsulamento baseado em propriedades privadas, ligadas a métodos especiais chamados getters e setters, que irão retornar e setar o valor da propriedade, respetivamente. Essa atitude evita o acesso direto a propriedade do objeto, adicionando uma outra camada de segurança à aplicação.
							</p>
							<img src="./imagens/trabalho1/imagem8.png" alt="">
						</div>
						<div class="t5s16_19">
							<h3>Os seus 4 pilares</h3>
							<h4>3- Herança</h4>
							<p>O objeto abaixo na hierarquia irá herdar características de todos os objetos acima dele, seus “ancestrais”. A herança a partir das características do objeto mais acima é considerada herança direta, enquanto as demais são consideradas heranças indiretas. Por exemplo, na família, a criança herda diretamente do pai e indiretamente do avô e do bisavô.
							</p>
							<img src="./imagens/trabalho1/imagem8.png" alt="">
						</div>
						<div class="t5s16_19">
							<h3>Os seus 4 pilares</h3>
							<h4>4- Polimorfismo</h4>
							<p>
								Na natureza, vemos animais que são capazes de alterar sua forma conforme a necessidade, e é dessa ideia que vem o polimorfismo na orientação a objetos. Como sabemos, os objetos filhos herdam as características e ações de seus “ancestrais”. Entretanto, em alguns casos, é necessário que as ações para um mesmo método seja diferente.<br/>
								Por exemplo, temos um objeto “Eletrodoméstico”. Esse objeto possui um método, ou ação, “Ligar()”. Temos dois objetos, “Televisão” e “Frigorifico”, que não irão ser ligados da mesma forma. Assim, precisamos, para cada uma das classes filhas, reescrever o método “Ligar()”.
							</p>
							<img src="./imagens/trabalho1/imagem8.png" alt="">
						</div>
						<div class="t5s20">
							<h3>Conclusão</h3>
							<p>
								Os tipos de metodologias são: metodologia ágil, Scrum, Kanban, Cascata e Lean.<br/>
								As principais vantagens são: na metodologia ágil os eventuais problemas do software podem ser corrigidos ainda em seu estágio inicial, Scrum a capacidade da equipe em identificar e corrigir desafios emergentes, Kanban toda a equipe se torna responsável pela tomada de decisões, Cascata impõe uma sequência restrita e bem dimensionada de tarefas, Lean todo o projeto é examinado minuciosamente já em sua fase inicial.<br/>
								A programação orientada por objeto é um paradigma de programação baseado no conceito de "objetos“. Os seus 4 pilares são: abstração, encapsulamento, herança, polimorfismo.
							</p>
						</div>
					</div>
				</details>
			</div>
		</div>

		<!--Script da barra lateral-->
		<script type="text/javascript">
			let progress = document.getElementById('barra');
			let totalHeight = document.body.scrollHeight - window.innerHeight;
			window.onscroll = function(){
				let progressHeight = (window.pageYOffset / totalHeight) * 100;
				progress.style.height = progressHeight + "%";
			}
		</script>
	</body>
</html>